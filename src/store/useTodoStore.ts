import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { v4 as uuidv4 } from 'uuid';
import * as FileSystem from 'expo-file-system';
import { Platform } from 'react-native';
import { AppStateProps, AppState, Todo, Habit, Diary, Settings, HabitPeriod } from '../models/types';
import { todoSchema, habitSchema, diarySchema } from '../models/schemas';
import { mockHabits } from '../utils/mockHabits';
import { generateRandomLightColor } from '../constants/colors';

const initialState: AppStateProps = {
    todos: [],
    habits: JSON.parse(JSON.stringify(mockHabits)),
    diaries: [],
    settings: {
      soundEnabled: true,
      habitReminderEnabled: false,
      defaultDiaryTemplate: 'simple',
      defaultSort: 'priority',
      defaultTomatoTime: undefined,
    },
    editingTodoId: null,
  };

export const useTodoStore = create<AppState>()(
  persist(
    (set, get) => ({
      ...initialState,

      // Todo actions
      addTodo: (todo: Omit<Todo, "id" | "createdAt" | "status" | "backgroundColor" | "priority">) => {
        try {
          const newTodo: Todo = {
            ...todo,
            id: uuidv4(),
            createdAt: new Date().toISOString(),
            status: 'pending',
            priority: 50,
            backgroundColor: generateRandomLightColor(),
            targetCount: todo.targetCount || 1,
            completedCount: todo.completedCount || 0
          };
          todoSchema.validateSync(newTodo);
          set((state) => ({ todos: [...state.todos, newTodo] }));
        } catch (error) {
          console.error('Validation error:', error);
        }
      },

      updateTodo: (id: string, updates: any) => {
        try {
          set((state) => ({
            todos: state.todos.map((todo) =>
              todo.id === id ? { ...todo, ...updates } : todo
            ),
          }));
        } catch (error) {
          console.error('Update error:', error);
        }
      },

      deleteTodo: (id: string) => {
        set((state) => ({
          todos: state.todos.filter((todo) => todo.id !== id),
        }));
      },

      reorderTodos: (newOrder: any[]) => {
        // Validate the new order contains all todos
        const currentIds = get().todos.map((t) => t.id);
        const newIds = newOrder.map((t) => t.id);
        
        if (currentIds.sort().join() !== newIds.sort().join()) {
          console.error('Invalid reorder operation');
          return;
        }

        set({ todos: newOrder });
      },

      // Habit actions
      addHabit: (habit: Omit<Habit, "id" | "createdAt" | "status" | "periodEndDate">) => {
        try {
          const newHabit: Habit = {
            ...habit,
            id: uuidv4(),
            createdAt: new Date().toISOString(),
            status: 'pending',
            priority: habit.priority || 50,
            periodEndDate: calculatePeriodEndDate(habit.period),
          };
          habitSchema.validateSync(newHabit);
          set((state) => ({ habits: [...state.habits, newHabit] }));
        } catch (error) {
          console.error('Validation error:', error);
        }
      },

      // Diary actions
      addDiary: (diary: Diary) => {
        try {
          diarySchema.validateSync(diary);
          set((state) => ({ diaries: [...state.diaries, diary] }));
        } catch (error) {
          console.error('Validation error:', error);
        }
      },

      // Settings actions
      updateSettings: (updates: Partial<Settings>) => {
        set((state) => ({
          settings: { ...state.settings, ...updates },
        }));
      },

      // History functions
      daychange: async () => {
        const today = new Date();
        const dateStr = today.toISOString().split('T')[0];
        const doneTodos = get().todos.filter(todo => todo.status === 'done');
        
        if (doneTodos.length === 0) return;

        if (Platform.OS === 'web') {
          // Web implementation using localStorage
          try {
            localStorage.setItem(`todo-history-${dateStr}`, JSON.stringify(doneTodos));
            set((state) => ({
              todos: state.todos.filter(todo => todo.status !== 'done')
            }));
          } catch (error) {
            console.error('Error saving history to localStorage:', error);
          }
        } else {
          // Native implementation using expo-file-system
          try {
            const historyDir = `${FileSystem.documentDirectory}history`;
            const dirInfo = await FileSystem.getInfoAsync(historyDir);
            if (!dirInfo.exists) {
              await FileSystem.makeDirectoryAsync(historyDir, { intermediates: true });
            }
            const filePath = `${historyDir}/${dateStr}.json`;
            await FileSystem.writeAsStringAsync(filePath, JSON.stringify(doneTodos));
            set((state) => ({
              todos: state.todos.filter(todo => todo.status !== 'done')
            }));
          } catch (error) {
            console.error('Error in daychange:', error);
          }
        }
      },
    }),
    {
      name: 'todo-app-storage-v2', // Changed storage name
      partialize: (state) => {
        console.log('Persisting state:', state);
        return {
          todos: state.todos,
          habits: state.habits,
          diaries: state.diaries,
          settings: state.settings,
        };
      },
      onRehydrateStorage: () => {
        return (state) => {
          console.log('Rehydrated state:', state);
        };
      },
    }
  )
);

// Helper function to calculate period end date
function calculatePeriodEndDate(period: HabitPeriod): string {
  const now = new Date();
  switch (period) {
    case 'daily':
      now.setHours(23, 59, 59, 999);
      break;
    case 'weekly':
      now.setDate(now.getDate() + (7 - now.getDay())); // Next Sunday
      now.setHours(23, 59, 59, 999);
      break;
    case 'monthly':
      now.setMonth(now.getMonth() + 1);
      now.setDate(0); // Last day of current month
      now.setHours(23, 59, 59, 999);
      break;
    case 'custom':
      now.setDate(now.getDate() + 1); // Default to next day
      now.setHours(23, 59, 59, 999);
      break;
  }
  return now.toISOString();
}
